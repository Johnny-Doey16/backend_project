// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: accounts.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createUserAccountDetails = `-- name: CreateUserAccountDetails :exec
INSERT INTO accounts (user_id, account_name, account_number, bank_name)
VALUES ($1, $2, $3, $4)
`

type CreateUserAccountDetailsParams struct {
	UserID        uuid.UUID      `json:"user_id"`
	AccountName   sql.NullString `json:"account_name"`
	AccountNumber sql.NullString `json:"account_number"`
	BankName      sql.NullString `json:"bank_name"`
}

func (q *Queries) CreateUserAccountDetails(ctx context.Context, arg CreateUserAccountDetailsParams) error {
	_, err := q.db.ExecContext(ctx, createUserAccountDetails,
		arg.UserID,
		arg.AccountName,
		arg.AccountNumber,
		arg.BankName,
	)
	return err
}

const getUserAccountDetails = `-- name: GetUserAccountDetails :one
SELECT id, user_id, account_name, account_number, bank_name, total_coin FROM accounts
WHERE user_id = $1
`

func (q *Queries) GetUserAccountDetails(ctx context.Context, userID uuid.UUID) (Account, error) {
	row := q.db.QueryRowContext(ctx, getUserAccountDetails, userID)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountName,
		&i.AccountNumber,
		&i.BankName,
		&i.TotalCoin,
	)
	return i, err
}

const increaseTotalCoin = `-- name: IncreaseTotalCoin :one



UPDATE accounts
SET total_coin = total_coin + $1
WHERE user_id = $2
RETURNING total_coin
`

type IncreaseTotalCoinParams struct {
	TotalCoin sql.NullString `json:"total_coin"`
	UserID    uuid.UUID      `json:"user_id"`
}

// CREATE OR REPLACE FUNCTION subtract_from_balance(user_id_param UUID, amount DECIMAL) RETURNS VOID AS $$
// BEGIN
//
//	-- Check if the user has enough balance
//	IF (SELECT total_coin FROM accounts WHERE user_id = user_id_param) < amount THEN
//	    RAISE EXCEPTION 'Insufficient funds';
//	ELSE
//	    -- Perform the update if the balance is sufficient
//	    UPDATE accounts
//	    SET total_coin = total_coin - amount
//	    WHERE user_id = user_id_param;
//	END IF;
//
// END;
// $$ LANGUAGE plpgsql;
// -- name: SubtractTotalCoin2 :exec
// SELECT subtract_from_balance('99dc65d6-6bec-4f72-8df0-18949eea1ff8', 200);
func (q *Queries) IncreaseTotalCoin(ctx context.Context, arg IncreaseTotalCoinParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, increaseTotalCoin, arg.TotalCoin, arg.UserID)
	var total_coin sql.NullString
	err := row.Scan(&total_coin)
	return total_coin, err
}

const subtractTotalCoin = `-- name: SubtractTotalCoin :exec
DO $$
DECLARE
    user_id_val UUID := $1;
    amount DECIMAL := $2;
BEGIN
    UPDATE accounts
    SET total_coin = CASE 
                        WHEN total_coin >= amount THEN total_coin - amount
                        ELSE total_coin 
                    END
    WHERE user_id = user_id_val;

    IF NOT EXISTS (SELECT 1 FROM accounts WHERE user_id = user_id_val AND total_coin >= amount) THEN
        RAISE EXCEPTION 'Insufficient funds';
    END IF;
END $$
`

func (q *Queries) SubtractTotalCoin(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, subtractTotalCoin)
	return err
}

const updateUserAccountDetails = `-- name: UpdateUserAccountDetails :exec
UPDATE accounts SET account_name = $1, account_number = $2, bank_name = $3 WHERE user_id = $4
`

type UpdateUserAccountDetailsParams struct {
	AccountName   sql.NullString `json:"account_name"`
	AccountNumber sql.NullString `json:"account_number"`
	BankName      sql.NullString `json:"bank_name"`
	UserID        uuid.UUID      `json:"user_id"`
}

func (q *Queries) UpdateUserAccountDetails(ctx context.Context, arg UpdateUserAccountDetailsParams) error {
	_, err := q.db.ExecContext(ctx, updateUserAccountDetails,
		arg.AccountName,
		arg.AccountNumber,
		arg.BankName,
		arg.UserID,
	)
	return err
}
