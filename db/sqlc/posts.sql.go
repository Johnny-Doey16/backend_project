// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: posts.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const checkPostStatus = `-- name: CheckPostStatus :one
SELECT
    id AS post_id,
    CASE
        WHEN deleted_at IS NOT NULL THEN 'deleted'
        WHEN suspended_at IS NOT NULL THEN 'suspended'
        ELSE 'active'
    END AS post_status
FROM
    posts
WHERE
    id = $1
`

type CheckPostStatusRow struct {
	PostID     uuid.UUID `json:"post_id"`
	PostStatus string    `json:"post_status"`
}

func (q *Queries) CheckPostStatus(ctx context.Context, id uuid.UUID) (CheckPostStatusRow, error) {
	row := q.db.QueryRowContext(ctx, checkPostStatus, id)
	var i CheckPostStatusRow
	err := row.Scan(&i.PostID, &i.PostStatus)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
    id, user_id, content, total_images, created_at
    )
VALUES ($1, $2, $3, $4, now())
RETURNING id, user_id, content, total_images, created_at, updated_at, suspended_at, deleted_at
`

type CreatePostParams struct {
	ID          uuid.UUID     `json:"id"`
	UserID      uuid.UUID     `json:"user_id"`
	Content     string        `json:"content"`
	TotalImages sql.NullInt32 `json:"total_images"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Content,
		arg.TotalImages,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.TotalImages,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SuspendedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createPostMention = `-- name: CreatePostMention :exec
INSERT INTO post_mentions (mentioned_user_id, post_id)
SELECT mentioned_user_id, $2
FROM UNNEST($1::uuid[]) AS mentioned_user_id
`

type CreatePostMentionParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	PostID  uuid.UUID   `json:"post_id"`
}

func (q *Queries) CreatePostMention(ctx context.Context, arg CreatePostMentionParams) error {
	_, err := q.db.ExecContext(ctx, createPostMention, pq.Array(arg.Column1), arg.PostID)
	return err
}

const getPostById = `-- name: GetPostById :one
WITH Post_With_Images AS (
    SELECT
        p.id AS post_id,
        p.content,
        p.total_images,
        p.created_at AS post_created_at,
        p.updated_at AS post_updated_at,
        p.suspended_at AS post_suspended_at,
        p.deleted_at AS post_deleted_at,
        pi.image_url AS post_image_url,
        pi.caption AS post_image_caption,
        pm.views,
        pm.likes,
        pm.comments,
        pm.reposts,
        a.username,
        e.image_url,
        e.user_id,
        a.user_type,
        a.is_verified,
        json_agg(pi.image_url) AS image_urls, -- Aggregate image URLs into a JSON array
        e.followers_count,
        e.following_count

    FROM
        posts p
    LEFT JOIN
        posts_images pi ON p.id = pi.post_id
    LEFT JOIN
        posts_metrics pm ON p.id = pm.post_id
    INNER JOIN
        authentications a ON p.user_id = a.id
    INNER JOIN 
      entity_profiles e ON p.user_id = e.user_id
    WHERE
        p.id = $1
    GROUP BY
        p.id, p.content, p.total_images, p.created_at, p.updated_at, p.suspended_at, p.deleted_at, e.user_id,
        pm.views, pm.likes, pm.comments, pm.reposts, a.username, e.image_url, a.user_type, pi.image_url, pi.caption,
        a.is_verified, e.followers_count, e.following_count
)
SELECT post_id, content, total_images, post_created_at, post_updated_at, post_suspended_at, post_deleted_at, post_image_url, post_image_caption, views, likes, comments, reposts, username, image_url, user_id, user_type, is_verified, image_urls, followers_count, following_count FROM Post_With_Images
`

type GetPostByIdRow struct {
	PostID           uuid.UUID       `json:"post_id"`
	Content          string          `json:"content"`
	TotalImages      sql.NullInt32   `json:"total_images"`
	PostCreatedAt    sql.NullTime    `json:"post_created_at"`
	PostUpdatedAt    sql.NullTime    `json:"post_updated_at"`
	PostSuspendedAt  sql.NullTime    `json:"post_suspended_at"`
	PostDeletedAt    sql.NullTime    `json:"post_deleted_at"`
	PostImageUrl     sql.NullString  `json:"post_image_url"`
	PostImageCaption sql.NullString  `json:"post_image_caption"`
	Views            sql.NullInt32   `json:"views"`
	Likes            sql.NullInt32   `json:"likes"`
	Comments         sql.NullInt32   `json:"comments"`
	Reposts          sql.NullInt32   `json:"reposts"`
	Username         sql.NullString  `json:"username"`
	ImageUrl         sql.NullString  `json:"image_url"`
	UserID           uuid.UUID       `json:"user_id"`
	UserType         string          `json:"user_type"`
	IsVerified       sql.NullBool    `json:"is_verified"`
	ImageUrls        json.RawMessage `json:"image_urls"`
	FollowersCount   sql.NullInt32   `json:"followers_count"`
	FollowingCount   sql.NullInt32   `json:"following_count"`
}

func (q *Queries) GetPostById(ctx context.Context, id uuid.UUID) (GetPostByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getPostById, id)
	var i GetPostByIdRow
	err := row.Scan(
		&i.PostID,
		&i.Content,
		&i.TotalImages,
		&i.PostCreatedAt,
		&i.PostUpdatedAt,
		&i.PostSuspendedAt,
		&i.PostDeletedAt,
		&i.PostImageUrl,
		&i.PostImageCaption,
		&i.Views,
		&i.Likes,
		&i.Comments,
		&i.Reposts,
		&i.Username,
		&i.ImageUrl,
		&i.UserID,
		&i.UserType,
		&i.IsVerified,
		&i.ImageUrls,
		&i.FollowersCount,
		&i.FollowingCount,
	)
	return i, err
}

const getPostByUserID = `-- name: GetPostByUserID :many
SELECT
  p.id, p.user_id, p.content, p.total_images, p.created_at, p.updated_at, p.suspended_at, p.deleted_at,
  CASE
    WHEN u.user_type = 'user' THEN us.first_name
    WHEN u.user_type = 'churchAdmin' THEN c.name
  END AS name,
  u.username,
  u.is_verified,
  u.user_type,
  us.first_name AS user_first_name,  -- Rename to avoid ambiguity
  us.last_name,
  ep.entity_type,
  ep.following_count,
  ep.followers_count,
  ep.image_url AS user_image_url,
  json_agg(pi.image_url) AS post_image_urls,
  pm.views,
  pm.likes,
  pm.comments,
  pm.reposts,
  EXISTS (
        SELECT 1 FROM likes l WHERE l.post_id = p.id AND l.user_id = $1
    ) AS post_liked
FROM (
  SELECT DISTINCT ON (ps.id)
    ps.id, ps.user_id, ps.content, ps.total_images, ps.created_at, ps.updated_at, ps.suspended_at, ps.deleted_at
  FROM posts ps
  WHERE ps.user_id = $1
    AND ps.deleted_at IS NULL
    AND ps.suspended_at IS NULL
  ORDER BY ps.id, ps.created_at DESC
  LIMIT $2 OFFSET $3
) p
JOIN authentications u ON p.user_id = u.id
LEFT JOIN blocked_users bu ON (bu.blocking_user_id = $1 AND bu.blocked_user_id = p.user_id)
    OR (bu.blocking_user_id = p.user_id AND bu.blocked_user_id = $1)
JOIN entity_profiles ep ON p.user_id = ep.user_id
LEFT JOIN users us ON u.id = us.user_id
LEFT JOIN churches c ON u.id = c.auth_id
LEFT JOIN posts_images pi ON p.id = pi.post_id
LEFT JOIN posts_metrics pm ON p.id = pm.post_id
GROUP BY
    p.id,
  p.user_id,
  p.content,
  p.created_at,
  p.total_images,
  p.updated_at,
  p.suspended_at,
  p.deleted_at,
  u.username,
  u.is_verified,
  u.user_type,
  us.first_name,
  us.last_name,
  c.name,
  ep.entity_type,
  ep.following_count,
  ep.followers_count,
  ep.image_url,
  pm.views,
  pm.likes,
  pm.comments,
  pm.reposts,
  post_liked
ORDER BY p.created_at DESC
`

type GetPostByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetPostByUserIDRow struct {
	ID             uuid.UUID       `json:"id"`
	UserID         uuid.UUID       `json:"user_id"`
	Content        string          `json:"content"`
	TotalImages    sql.NullInt32   `json:"total_images"`
	CreatedAt      sql.NullTime    `json:"created_at"`
	UpdatedAt      sql.NullTime    `json:"updated_at"`
	SuspendedAt    sql.NullTime    `json:"suspended_at"`
	DeletedAt      sql.NullTime    `json:"deleted_at"`
	Name           interface{}     `json:"name"`
	Username       sql.NullString  `json:"username"`
	IsVerified     sql.NullBool    `json:"is_verified"`
	UserType       string          `json:"user_type"`
	UserFirstName  sql.NullString  `json:"user_first_name"`
	LastName       sql.NullString  `json:"last_name"`
	EntityType     string          `json:"entity_type"`
	FollowingCount sql.NullInt32   `json:"following_count"`
	FollowersCount sql.NullInt32   `json:"followers_count"`
	UserImageUrl   sql.NullString  `json:"user_image_url"`
	PostImageUrls  json.RawMessage `json:"post_image_urls"`
	Views          sql.NullInt32   `json:"views"`
	Likes          sql.NullInt32   `json:"likes"`
	Comments       sql.NullInt32   `json:"comments"`
	Reposts        sql.NullInt32   `json:"reposts"`
	PostLiked      bool            `json:"post_liked"`
}

func (q *Queries) GetPostByUserID(ctx context.Context, arg GetPostByUserIDParams) ([]GetPostByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostByUserIDRow{}
	for rows.Next() {
		var i GetPostByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.TotalImages,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SuspendedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Username,
			&i.IsVerified,
			&i.UserType,
			&i.UserFirstName,
			&i.LastName,
			&i.EntityType,
			&i.FollowingCount,
			&i.FollowersCount,
			&i.UserImageUrl,
			&i.PostImageUrls,
			&i.Views,
			&i.Likes,
			&i.Comments,
			&i.Reposts,
			&i.PostLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByFollowing = `-- name: GetPostsByFollowing :many
SELECT p.id, p.user_id, p.content, p.total_images, p.created_at, p.updated_at, p.suspended_at, p.deleted_at
FROM posts p
LEFT JOIN follow f ON p.user_id = f.following_user_id
WHERE f.follower_user_id = $1 OR p.user_id = $1
ORDER BY p.created_at DESC
`

func (q *Queries) GetPostsByFollowing(ctx context.Context, followerUserID uuid.UUID) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsByFollowing, followerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Post{}
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.TotalImages,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SuspendedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserFollowing = `-- name: IsUserFollowing :one
SELECT follower_user_id, following_user_id, created_at
FROM follow
WHERE follower_user_id = $1 AND following_user_id = $2
LIMIT 1
`

type IsUserFollowingParams struct {
	FollowerUserID  uuid.UUID `json:"follower_user_id"`
	FollowingUserID uuid.UUID `json:"following_user_id"`
}

func (q *Queries) IsUserFollowing(ctx context.Context, arg IsUserFollowingParams) (Follow, error) {
	row := q.db.QueryRowContext(ctx, isUserFollowing, arg.FollowerUserID, arg.FollowingUserID)
	var i Follow
	err := row.Scan(&i.FollowerUserID, &i.FollowingUserID, &i.CreatedAt)
	return i, err
}
