// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: announcements.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const checkAnnouncementStatus = `-- name: CheckAnnouncementStatus :one
SELECT
    id AS post_id,
    CASE
        WHEN deleted_at IS NOT NULL THEN 'deleted'
        WHEN suspended_at IS NOT NULL THEN 'suspended'
        ELSE 'active'
    END AS post_status
FROM
    announcements
WHERE
    id = $1
`

type CheckAnnouncementStatusRow struct {
	PostID     uuid.UUID `json:"post_id"`
	PostStatus string    `json:"post_status"`
}

func (q *Queries) CheckAnnouncementStatus(ctx context.Context, id uuid.UUID) (CheckAnnouncementStatusRow, error) {
	row := q.db.QueryRowContext(ctx, checkAnnouncementStatus, id)
	var i CheckAnnouncementStatusRow
	err := row.Scan(&i.PostID, &i.PostStatus)
	return i, err
}

const createAnnouncements = `-- name: CreateAnnouncements :exec
INSERT INTO announcements (
    id, user_id, title, content, total_images, created_at
    )
VALUES ($1, $2, $3, $4, 0, now())
`

type CreateAnnouncementsParams struct {
	ID      uuid.UUID `json:"id"`
	UserID  uuid.UUID `json:"user_id"`
	Title   string    `json:"title"`
	Content string    `json:"content"`
}

func (q *Queries) CreateAnnouncements(ctx context.Context, arg CreateAnnouncementsParams) error {
	_, err := q.db.ExecContext(ctx, createAnnouncements,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Content,
	)
	return err
}

const getAnnouncementById = `-- name: GetAnnouncementById :one
SELECT id, user_id, title, content, total_images, created_at, updated_at, suspended_at, deleted_at FROM announcements
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetAnnouncementById(ctx context.Context, id uuid.UUID) (Announcement, error) {
	row := q.db.QueryRowContext(ctx, getAnnouncementById, id)
	var i Announcement
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Content,
		&i.TotalImages,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SuspendedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAnnouncementsByUserID = `-- name: GetAnnouncementsByUserID :many
SELECT
  p.id, p.user_id, p.title, p.content, p.total_images, p.created_at, p.updated_at, p.suspended_at, p.deleted_at,
  c.name,
  u.username,
  u.is_verified,
  ep.entity_type,
  ep.following_count,
  ep.followers_count,
  ep.image_url AS user_image_url
FROM (
  SELECT DISTINCT ON (ps.id)
    ps.id, ps.user_id, ps.title, ps.content, ps.total_images, ps.created_at, ps.updated_at, ps.suspended_at, ps.deleted_at
  FROM announcements ps
  WHERE ps.user_id = $1
  ORDER BY ps.id, ps.created_at DESC
  LIMIT $2 OFFSET $3
) p
JOIN authentications u ON p.user_id = u.id
JOIN entity_profiles ep ON p.user_id = ep.user_id
LEFT JOIN churches c ON u.id = c.auth_id
GROUP BY
    p.id,
  p.user_id,
  p.total_images,
  p.title,
  p.content,
  p.created_at,
  p.updated_at,
  p.suspended_at,
  p.deleted_at,
  u.username,
  u.is_verified,
  u.user_type,
  c.name,
  ep.entity_type,
  ep.following_count,
  ep.followers_count,
  ep.image_url
ORDER BY p.created_at DESC
`

type GetAnnouncementsByUserIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetAnnouncementsByUserIDRow struct {
	ID             uuid.UUID      `json:"id"`
	UserID         uuid.UUID      `json:"user_id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	TotalImages    sql.NullInt32  `json:"total_images"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	SuspendedAt    sql.NullTime   `json:"suspended_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	Name           sql.NullString `json:"name"`
	Username       sql.NullString `json:"username"`
	IsVerified     sql.NullBool   `json:"is_verified"`
	EntityType     string         `json:"entity_type"`
	FollowingCount sql.NullInt32  `json:"following_count"`
	FollowersCount sql.NullInt32  `json:"followers_count"`
	UserImageUrl   sql.NullString `json:"user_image_url"`
}

func (q *Queries) GetAnnouncementsByUserID(ctx context.Context, arg GetAnnouncementsByUserIDParams) ([]GetAnnouncementsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAnnouncementsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnnouncementsByUserIDRow{}
	for rows.Next() {
		var i GetAnnouncementsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.TotalImages,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SuspendedAt,
			&i.DeletedAt,
			&i.Name,
			&i.Username,
			&i.IsVerified,
			&i.EntityType,
			&i.FollowingCount,
			&i.FollowersCount,
			&i.UserImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnnouncementsForUser = `-- name: GetAnnouncementsForUser :many
SELECT 
    a.id, a.user_id, a.title, a.content, a.total_images, a.created_at, a.updated_at, a.suspended_at, a.deleted_at,
    c.name AS church_name,
    ep.image_url AS church_image_url,
    u.is_verified AS church_verified,
    u.username
FROM 
    announcements a
JOIN
  entity_profiles ep ON a.user_id = ep.user_id
JOIN 
    authentications u ON a.user_id = u.id
JOIN 
    churches c ON u.id = c.auth_id
JOIN 
    user_church_membership m ON m.church_id = c.id
WHERE 
    m.user_id = $1
    AND u.is_suspended = false
    AND u.is_deleted = false
    AND a.suspended_at IS NULL
    AND a.deleted_at IS NULL
    ORDER BY a.created_at DESC
      LIMIT $2 OFFSET $3
`

type GetAnnouncementsForUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetAnnouncementsForUserRow struct {
	ID             uuid.UUID      `json:"id"`
	UserID         uuid.UUID      `json:"user_id"`
	Title          string         `json:"title"`
	Content        string         `json:"content"`
	TotalImages    sql.NullInt32  `json:"total_images"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	SuspendedAt    sql.NullTime   `json:"suspended_at"`
	DeletedAt      sql.NullTime   `json:"deleted_at"`
	ChurchName     string         `json:"church_name"`
	ChurchImageUrl sql.NullString `json:"church_image_url"`
	ChurchVerified sql.NullBool   `json:"church_verified"`
	Username       sql.NullString `json:"username"`
}

func (q *Queries) GetAnnouncementsForUser(ctx context.Context, arg GetAnnouncementsForUserParams) ([]GetAnnouncementsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAnnouncementsForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAnnouncementsForUserRow{}
	for rows.Next() {
		var i GetAnnouncementsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.TotalImages,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SuspendedAt,
			&i.DeletedAt,
			&i.ChurchName,
			&i.ChurchImageUrl,
			&i.ChurchVerified,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
