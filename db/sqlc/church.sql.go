// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: church.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createChurchForUser = `-- name: CreateChurchForUser :one
WITH valid_user AS (
  SELECT user_id
  FROM users
  JOIN churches ON users.denomination_id = churches.denomination_id
  WHERE user_id = $1
    AND users.denomination_id IS NOT NULL
    AND churches.id = $2
),
updated_users AS (
  UPDATE users
  SET church_id = $2, last_church_change = NOW()
  WHERE user_id IN (SELECT user_id FROM valid_user)
    AND users.church_id IS DISTINCT FROM $2
    AND (users.last_church_change IS NULL OR users.last_church_change < NOW() - INTERVAL '6 month')
  RETURNING id
)
INSERT INTO user_church_membership (user_id, church_id, join_date, active)
SELECT $1, $2, NOW(), TRUE
FROM updated_users
WHERE NOT EXISTS (
  SELECT 1 FROM user_church_membership
  WHERE user_id = $1 AND church_id = $2 AND active
)
AND (
  SELECT COUNT(*)
  FROM user_church_membership
  WHERE user_id = $1 AND active AND join_date >= NOW() - INTERVAL '6 month'
) = 0
RETURNING id, user_id, church_id, join_date, leave_date, active
`

type CreateChurchForUserParams struct {
	UserID   uuid.UUID `json:"user_id"`
	ChurchID int32     `json:"church_id"`
}

func (q *Queries) CreateChurchForUser(ctx context.Context, arg CreateChurchForUserParams) (UserChurchMembership, error) {
	row := q.db.QueryRowContext(ctx, createChurchForUser, arg.UserID, arg.ChurchID)
	var i UserChurchMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChurchID,
		&i.JoinDate,
		&i.LeaveDate,
		&i.Active,
	)
	return i, err
}

const createNewChurch = `-- name: CreateNewChurch :exec
INSERT INTO churches (auth_id, denomination_id, name)
VALUES ($1, $2, $3)
`

type CreateNewChurchParams struct {
	AuthID         uuid.UUID `json:"auth_id"`
	DenominationID int32     `json:"denomination_id"`
	Name           string    `json:"name"`
}

func (q *Queries) CreateNewChurch(ctx context.Context, arg CreateNewChurchParams) error {
	_, err := q.db.ExecContext(ctx, createNewChurch, arg.AuthID, arg.DenominationID, arg.Name)
	return err
}

const createNewChurchLocation = `-- name: CreateNewChurchLocation :exec
INSERT INTO church_locations (auth_id, address, city, postalCode, state, country, location, lga)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateNewChurchLocationParams struct {
	AuthID     uuid.UUID   `json:"auth_id"`
	Address    string      `json:"address"`
	City       string      `json:"city"`
	Postalcode string      `json:"postalcode"`
	State      string      `json:"state"`
	Country    string      `json:"country"`
	Location   interface{} `json:"location"`
	Lga        string      `json:"lga"`
}

func (q *Queries) CreateNewChurchLocation(ctx context.Context, arg CreateNewChurchLocationParams) error {
	_, err := q.db.ExecContext(ctx, createNewChurchLocation,
		arg.AuthID,
		arg.Address,
		arg.City,
		arg.Postalcode,
		arg.State,
		arg.Country,
		arg.Location,
		arg.Lga,
	)
	return err
}

const getChurchMembers5 = `-- name: GetChurchMembers5 :many


 
WITH user_details AS (
    SELECT
        u.id AS user_id,
        u.first_name,
        a.id AS auth_id,
        a.username,
        a.is_verified,
        ep.image_url,
        ucm.join_date
    FROM user_church_membership ucm
    JOIN users u ON ucm.user_id = u.user_id
    JOIN authentications a ON u.user_id = a.id
    LEFT JOIN entity_profiles ep ON a.id = ep.user_id
    WHERE ucm.church_id = $1 AND ucm.active = true AND a.id <> $2
)
SELECT
    jsonb_agg(user_details) AS user_details,
    EXISTS (
        SELECT 1
        FROM user_church_membership ucm
        WHERE ucm.church_id = $1 AND ucm.user_id = $2 AND ucm.active = true
    ) AS is_member
FROM user_details
OFFSET $3
LIMIT $4
`

type GetChurchMembers5Params struct {
	ChurchID int32     `json:"church_id"`
	UserID   uuid.UUID `json:"user_id"`
	Offset   int32     `json:"offset"`
	Limit    int32     `json:"limit"`
}

type GetChurchMembers5Row struct {
	UserDetails json.RawMessage `json:"user_details"`
	IsMember    bool            `json:"is_member"`
}

// AND a.is_verified = true;
// ! TODO: Add Order by join date
// GROUP BY join_date
// ORDER BY join_date
func (q *Queries) GetChurchMembers5(ctx context.Context, arg GetChurchMembers5Params) ([]GetChurchMembers5Row, error) {
	rows, err := q.db.QueryContext(ctx, getChurchMembers5,
		arg.ChurchID,
		arg.UserID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChurchMembers5Row{}
	for rows.Next() {
		var i GetChurchMembers5Row
		if err := rows.Scan(&i.UserDetails, &i.IsMember); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchMembersUid = `-- name: GetChurchMembersUid :many
SELECT uc.user_id
FROM user_church_membership uc
JOIN churches c ON uc.church_id = c.id
WHERE c.auth_id = $1
`

func (q *Queries) GetChurchMembersUid(ctx context.Context, authID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getChurchMembersUid, authID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var user_id uuid.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchProfile = `-- name: GetChurchProfile :one
SELECT
  c.id,
  c.auth_id,
  c.name,
  c.members_count,
  c.denomination_id,
  cl.address,
  cl.city,
  cl.postalCode,
  cl.state,
  cl.country,
  cl.location,
  cl.lga,
  a.username,
  a.phone,
  a.is_verified,
  ep.image_url,
  ep.header_image_url,
  ep.posts_count,
  ep.website,
  ep.about,
  ep.following_count,
  ep.followers_count,
  EXISTS (
        SELECT 1
        FROM follow f
        WHERE f.follower_user_id = $2 AND f.following_user_id = c.auth_id
    ) AS is_following,
    EXISTS (
        SELECT 1
        FROM follow f
        WHERE f.follower_user_id = c.auth_id AND f.following_user_id = $2
    ) AS is_followed,
    EXISTS (
        SELECT 1
        FROM user_church_membership ucm
        WHERE ucm.user_id = $2 AND ucm.church_id = c.id
    ) AS is_member
  
FROM
  churches c
JOIN
  church_locations cl ON c.auth_id = cl.auth_id
JOIN
  authentications a ON c.auth_id = a.id
JOIN
  entity_profiles ep ON a.id = ep.user_id
WHERE
  c.auth_id = $1
`

type GetChurchProfileParams struct {
	AuthID         uuid.UUID `json:"auth_id"`
	FollowerUserID uuid.UUID `json:"follower_user_id"`
}

type GetChurchProfileRow struct {
	ID             int32          `json:"id"`
	AuthID         uuid.UUID      `json:"auth_id"`
	Name           string         `json:"name"`
	MembersCount   sql.NullInt32  `json:"members_count"`
	DenominationID int32          `json:"denomination_id"`
	Address        string         `json:"address"`
	City           string         `json:"city"`
	Postalcode     string         `json:"postalcode"`
	State          string         `json:"state"`
	Country        string         `json:"country"`
	Location       interface{}    `json:"location"`
	Lga            string         `json:"lga"`
	Username       sql.NullString `json:"username"`
	Phone          sql.NullString `json:"phone"`
	IsVerified     sql.NullBool   `json:"is_verified"`
	ImageUrl       sql.NullString `json:"image_url"`
	HeaderImageUrl sql.NullString `json:"header_image_url"`
	PostsCount     sql.NullInt32  `json:"posts_count"`
	Website        sql.NullString `json:"website"`
	About          sql.NullString `json:"about"`
	FollowingCount sql.NullInt32  `json:"following_count"`
	FollowersCount sql.NullInt32  `json:"followers_count"`
	IsFollowing    bool           `json:"is_following"`
	IsFollowed     bool           `json:"is_followed"`
	IsMember       bool           `json:"is_member"`
}

func (q *Queries) GetChurchProfile(ctx context.Context, arg GetChurchProfileParams) (GetChurchProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getChurchProfile, arg.AuthID, arg.FollowerUserID)
	var i GetChurchProfileRow
	err := row.Scan(
		&i.ID,
		&i.AuthID,
		&i.Name,
		&i.MembersCount,
		&i.DenominationID,
		&i.Address,
		&i.City,
		&i.Postalcode,
		&i.State,
		&i.Country,
		&i.Location,
		&i.Lga,
		&i.Username,
		&i.Phone,
		&i.IsVerified,
		&i.ImageUrl,
		&i.HeaderImageUrl,
		&i.PostsCount,
		&i.Website,
		&i.About,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.IsFollowing,
		&i.IsFollowed,
		&i.IsMember,
	)
	return i, err
}

const getNearbyChurches = `-- name: GetNearbyChurches :many


SELECT
  c.id,
  c.auth_id,
  c.name,
  c.denomination_id,
  cl.address,
  cl.city,
  cl.postalCode,
  cl.state,
  cl.country,
  cl.location,
  cl.lga,
  ST_Distance(cl.location, ST_MakePoint($1, $2)::geography) AS distance,
  a.username,
  ep.image_url
FROM
  churches c
JOIN
  church_locations cl ON c.auth_id = cl.auth_id
JOIN
  authentications a ON c.auth_id = a.id
JOIN
  entity_profiles ep ON a.id = ep.user_id
WHERE
  ST_DWithin(
    cl.location,
    ST_MakePoint($1, $2)::geography,
    $3
)
ORDER BY
  ST_Distance(cl.location, ST_MakePoint($1, $2)::geography)
`

type GetNearbyChurchesParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
}

type GetNearbyChurchesRow struct {
	ID             int32          `json:"id"`
	AuthID         uuid.UUID      `json:"auth_id"`
	Name           string         `json:"name"`
	DenominationID int32          `json:"denomination_id"`
	Address        string         `json:"address"`
	City           string         `json:"city"`
	Postalcode     string         `json:"postalcode"`
	State          string         `json:"state"`
	Country        string         `json:"country"`
	Location       interface{}    `json:"location"`
	Lga            string         `json:"lga"`
	Distance       interface{}    `json:"distance"`
	Username       sql.NullString `json:"username"`
	ImageUrl       sql.NullString `json:"image_url"`
}

// Above can also search by denomination id
func (q *Queries) GetNearbyChurches(ctx context.Context, arg GetNearbyChurchesParams) ([]GetNearbyChurchesRow, error) {
	rows, err := q.db.QueryContext(ctx, getNearbyChurches, arg.StMakepoint, arg.StMakepoint_2, arg.StDwithin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNearbyChurchesRow{}
	for rows.Next() {
		var i GetNearbyChurchesRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthID,
			&i.Name,
			&i.DenominationID,
			&i.Address,
			&i.City,
			&i.Postalcode,
			&i.State,
			&i.Country,
			&i.Location,
			&i.Lga,
			&i.Distance,
			&i.Username,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAndChurchMembership = `-- name: GetUserAndChurchMembership :one


SELECT u.id, u.user_id, u.first_name, u.last_name, u.last_denomination_change, u.last_church_change, u.denomination_id, u.church_id, m.id, m.user_id, m.church_id, m.join_date, m.leave_date, m.active
FROM users u
LEFT JOIN user_church_membership m ON u.user_id = m.user_id AND m.active
WHERE u.user_id = $1
ORDER BY m.join_date DESC
LIMIT 1
`

type GetUserAndChurchMembershipRow struct {
	ID                     int32          `json:"id"`
	UserID                 uuid.UUID      `json:"user_id"`
	FirstName              sql.NullString `json:"first_name"`
	LastName               sql.NullString `json:"last_name"`
	LastDenominationChange sql.NullTime   `json:"last_denomination_change"`
	LastChurchChange       sql.NullTime   `json:"last_church_change"`
	DenominationID         sql.NullInt32  `json:"denomination_id"`
	ChurchID               sql.NullInt32  `json:"church_id"`
	ID_2                   sql.NullInt32  `json:"id_2"`
	UserID_2               uuid.NullUUID  `json:"user_id_2"`
	ChurchID_2             sql.NullInt32  `json:"church_id_2"`
	JoinDate               sql.NullTime   `json:"join_date"`
	LeaveDate              sql.NullTime   `json:"leave_date"`
	Active                 sql.NullBool   `json:"active"`
}

// *** *** *** *** *** *** *** ***
func (q *Queries) GetUserAndChurchMembership(ctx context.Context, userID uuid.UUID) (GetUserAndChurchMembershipRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAndChurchMembership, userID)
	var i GetUserAndChurchMembershipRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.LastDenominationChange,
		&i.LastChurchChange,
		&i.DenominationID,
		&i.ChurchID,
		&i.ID_2,
		&i.UserID_2,
		&i.ChurchID_2,
		&i.JoinDate,
		&i.LeaveDate,
		&i.Active,
	)
	return i, err
}

const getUserChurch = `-- name: GetUserChurch :one
WITH church_membership AS (
  SELECT
    ucm.church_id,
    c.denomination_id,
    c.members_count,
    c.name AS church_name,
    c.auth_id AS church_auth_id,
    EXISTS (
        SELECT 1
        FROM follow f
        WHERE f.follower_user_id = $1 AND f.following_user_id = c.auth_id
    ) AS is_following,
    EXISTS (
        SELECT 1
        FROM follow f
        WHERE f.follower_user_id = c.auth_id AND f.following_user_id = $1
    ) AS is_followed
  FROM
    user_church_membership ucm
  JOIN
    churches c ON ucm.church_id = c.id
  WHERE
    ucm.user_id = $1 -- Replace $4 with the actual user_id
    AND ucm.active = true
)

SELECT
  cm.church_id,
  cm.denomination_id,
  cm.church_name,
  cm.members_count,
  cm.church_auth_id,
  cm.is_followed,
  cm.is_following,
  a.email,
  a.username,
  a.is_verified,
  a.phone,
  ep.image_url,
  ep.following_count,
  ep.followers_count,
  ep.header_image_url,
  ep.posts_count,
  ep.website,
  ep.about,

  cl.address,
  cl.city,
  cl.postalcode,
  cl.state,
  cl.country,
  cl.lga,
  
  acc.account_name,
  acc.account_number,
  acc.bank_name,
  acc.total_coin
FROM
  church_membership cm
JOIN
  authentications a ON cm.church_auth_id = a.id
JOIN
  entity_profiles ep ON cm.church_auth_id = ep.user_id
JOIN
  church_locations cl ON cm.church_auth_id = cl.auth_id
LEFT JOIN
  accounts acc ON a.id = acc.user_id
WHERE
  a.is_suspended = false
  AND a.is_deleted = false
`

type GetUserChurchRow struct {
	ChurchID       int32          `json:"church_id"`
	DenominationID int32          `json:"denomination_id"`
	ChurchName     string         `json:"church_name"`
	MembersCount   sql.NullInt32  `json:"members_count"`
	ChurchAuthID   uuid.UUID      `json:"church_auth_id"`
	IsFollowed     bool           `json:"is_followed"`
	IsFollowing    bool           `json:"is_following"`
	Email          string         `json:"email"`
	Username       sql.NullString `json:"username"`
	IsVerified     sql.NullBool   `json:"is_verified"`
	Phone          sql.NullString `json:"phone"`
	ImageUrl       sql.NullString `json:"image_url"`
	FollowingCount sql.NullInt32  `json:"following_count"`
	FollowersCount sql.NullInt32  `json:"followers_count"`
	HeaderImageUrl sql.NullString `json:"header_image_url"`
	PostsCount     sql.NullInt32  `json:"posts_count"`
	Website        sql.NullString `json:"website"`
	About          sql.NullString `json:"about"`
	Address        string         `json:"address"`
	City           string         `json:"city"`
	Postalcode     string         `json:"postalcode"`
	State          string         `json:"state"`
	Country        string         `json:"country"`
	Lga            string         `json:"lga"`
	AccountName    sql.NullString `json:"account_name"`
	AccountNumber  sql.NullString `json:"account_number"`
	BankName       sql.NullString `json:"bank_name"`
	TotalCoin      sql.NullString `json:"total_coin"`
}

func (q *Queries) GetUserChurch(ctx context.Context, followerUserID uuid.UUID) (GetUserChurchRow, error) {
	row := q.db.QueryRowContext(ctx, getUserChurch, followerUserID)
	var i GetUserChurchRow
	err := row.Scan(
		&i.ChurchID,
		&i.DenominationID,
		&i.ChurchName,
		&i.MembersCount,
		&i.ChurchAuthID,
		&i.IsFollowed,
		&i.IsFollowing,
		&i.Email,
		&i.Username,
		&i.IsVerified,
		&i.Phone,
		&i.ImageUrl,
		&i.FollowingCount,
		&i.FollowersCount,
		&i.HeaderImageUrl,
		&i.PostsCount,
		&i.Website,
		&i.About,
		&i.Address,
		&i.City,
		&i.Postalcode,
		&i.State,
		&i.Country,
		&i.Lga,
		&i.AccountName,
		&i.AccountNumber,
		&i.BankName,
		&i.TotalCoin,
	)
	return i, err
}

const getUserChurchMembership = `-- name: GetUserChurchMembership :one
SELECT id, user_id, church_id, join_date, leave_date, active FROM user_church_membership
WHERE user_id = $1 AND church_id = $2 AND active
ORDER BY join_date DESC
LIMIT 1
`

type GetUserChurchMembershipParams struct {
	UserID   uuid.UUID `json:"user_id"`
	ChurchID int32     `json:"church_id"`
}

func (q *Queries) GetUserChurchMembership(ctx context.Context, arg GetUserChurchMembershipParams) (UserChurchMembership, error) {
	row := q.db.QueryRowContext(ctx, getUserChurchMembership, arg.UserID, arg.ChurchID)
	var i UserChurchMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChurchID,
		&i.JoinDate,
		&i.LeaveDate,
		&i.Active,
	)
	return i, err
}

const leaveChurch = `-- name: LeaveChurch :exec
UPDATE user_church_membership
SET active = FALSE, leave_date = NOW()
WHERE user_id = $1 AND active
  AND (join_date < NOW() - INTERVAL '6 month')
`

func (q *Queries) LeaveChurch(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, leaveChurch, userID)
	return err
}

const searchChurches = `-- name: SearchChurches :many
SELECT
  c.id,
  c.name,
  c.denomination_id,
  cl.address,
  cl.city,
  cl.postalCode,
  cl.state,
  cl.country,
  cl.location,
  cl.lga
FROM
  churches c
JOIN
  church_locations cl ON c.auth_id = cl.auth_id
WHERE
  c.name ILIKE '%' || $1 || '%'
  OR CAST(c.denomination_id AS TEXT) ILIKE '%' || $1 || '%'
  -- ORDER BY bookmarked_at DESC
  LIMIT $2 OFFSET $3
`

type SearchChurchesParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

type SearchChurchesRow struct {
	ID             int32       `json:"id"`
	Name           string      `json:"name"`
	DenominationID int32       `json:"denomination_id"`
	Address        string      `json:"address"`
	City           string      `json:"city"`
	Postalcode     string      `json:"postalcode"`
	State          string      `json:"state"`
	Country        string      `json:"country"`
	Location       interface{} `json:"location"`
	Lga            string      `json:"lga"`
}

func (q *Queries) SearchChurches(ctx context.Context, arg SearchChurchesParams) ([]SearchChurchesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchChurches, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchChurchesRow{}
	for rows.Next() {
		var i SearchChurchesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DenominationID,
			&i.Address,
			&i.City,
			&i.Postalcode,
			&i.State,
			&i.Country,
			&i.Location,
			&i.Lga,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChurchForUser = `-- name: UpdateChurchForUser :one
WITH valid_user AS (
  SELECT user_id
  FROM users u
  JOIN churches c ON u.denomination_id = c.denomination_id
  WHERE u.user_id = $2
    AND u.denomination_id IS NOT NULL
    AND c.id = $1
),
deactivated AS (
  UPDATE user_church_membership
  SET active = FALSE, leave_date = NOW()
  WHERE user_id IN (SELECT user_id FROM valid_user) AND active
  RETURNING user_id
),
updated_users AS (
  UPDATE users
  SET church_id = $1, last_church_change = NOW()
  FROM deactivated d
  WHERE users.user_id IN (SELECT user_id FROM valid_user)
    AND users.church_id IS DISTINCT FROM $1
    AND (users.last_church_change IS NULL OR users.last_church_change < (NOW() - INTERVAL '6 months'))
  RETURNING id
)
INSERT INTO user_church_membership (user_id, church_id, join_date, active)
SELECT $2, $1, NOW(), TRUE
FROM updated_users
RETURNING id, user_id, church_id, join_date, leave_date, active
`

type UpdateChurchForUserParams struct {
	ChurchID int32     `json:"church_id"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateChurchForUser(ctx context.Context, arg UpdateChurchForUserParams) (UserChurchMembership, error) {
	row := q.db.QueryRowContext(ctx, updateChurchForUser, arg.ChurchID, arg.UserID)
	var i UserChurchMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChurchID,
		&i.JoinDate,
		&i.LeaveDate,
		&i.Active,
	)
	return i, err
}

const updateChurchForUserOld = `-- name: UpdateChurchForUserOld :one
WITH valid_user AS (
  SELECT user_id
  FROM users
  JOIN churches ON users.denomination_id = churches.denomination_id
  WHERE users.user_id = $2
    AND users.denomination_id IS NOT NULL
    AND churches.id = $1
),
deactivated AS (
  UPDATE user_church_membership
  SET active = FALSE, leave_date = NOW()
  WHERE user_id IN (SELECT user_id FROM valid_user) AND active
  RETURNING user_id
),
updated_users AS (
  UPDATE users
  SET church_id = $1, last_church_change = NOW()
  FROM deactivated
  WHERE users.user_id IN (SELECT user_id FROM valid_user)
    AND users.church_id IS DISTINCT FROM $1
    AND (users.last_church_change IS NULL OR users.last_church_change < NOW() - INTERVAL '6 months')
  RETURNING id
)
INSERT INTO user_church_membership (user_id, church_id, join_date, active)
SELECT $2, $1, NOW(), TRUE
FROM updated_users
RETURNING id, user_id, church_id, join_date, leave_date, active
`

type UpdateChurchForUserOldParams struct {
	ChurchID int32     `json:"church_id"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateChurchForUserOld(ctx context.Context, arg UpdateChurchForUserOldParams) (UserChurchMembership, error) {
	row := q.db.QueryRowContext(ctx, updateChurchForUserOld, arg.ChurchID, arg.UserID)
	var i UserChurchMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ChurchID,
		&i.JoinDate,
		&i.LeaveDate,
		&i.Active,
	)
	return i, err
}
