// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: comments.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createComment = `-- name: CreateComment :one
INSERT INTO "post_comments" (
  "user_id",
  "post_id",
  "comment_text",
  "created_at"
) VALUES (
  $1, $2, $3, NOW()
)
RETURNING id, user_id, post_id, comment_text, created_at, updated_at
`

type CreateCommentParams struct {
	UserID      uuid.UUID `json:"user_id"`
	PostID      uuid.UUID `json:"post_id"`
	CommentText string    `json:"comment_text"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (PostComment, error) {
	row := q.db.QueryRowContext(ctx, createComment, arg.UserID, arg.PostID, arg.CommentText)
	var i PostComment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CommentText,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM "post_comments"
WHERE "id" = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteComment, id)
	return err
}

const getCommentByID = `-- name: GetCommentByID :one
SELECT id, user_id, post_id, comment_text, created_at, updated_at FROM "post_comments"
WHERE "id" = $1
`

func (q *Queries) GetCommentByID(ctx context.Context, id int32) (PostComment, error) {
	row := q.db.QueryRowContext(ctx, getCommentByID, id)
	var i PostComment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CommentText,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCommentsByPostID = `-- name: ListCommentsByPostID :many
SELECT id, user_id, post_id, comment_text, created_at, updated_at FROM "post_comments"
WHERE "post_id" = $1
ORDER BY "created_at" DESC
LIMIT $2 OFFSET $3
`

type ListCommentsByPostIDParams struct {
	PostID uuid.UUID `json:"post_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListCommentsByPostID(ctx context.Context, arg ListCommentsByPostIDParams) ([]PostComment, error) {
	rows, err := q.db.QueryContext(ctx, listCommentsByPostID, arg.PostID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PostComment{}
	for rows.Next() {
		var i PostComment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.CommentText,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recommendComments = `-- name: RecommendComments :many
SELECT
  pc.id AS comment_id,
  pc.comment_text,
  pc.created_at AS comment_created_at,
  pc.updated_at AS comment_updated_at,
  u.id AS user_id,
  u.username AS commenter_username,
  ep.image_url,
  us.first_name,
  CASE
    WHEN f.following_user_id IS NOT NULL THEN 1
    ELSE 0
  END AS is_following_commenter
FROM
  post_comments pc
JOIN authentications u ON
  pc.user_id = u.id

JOIN entity_profiles ep ON u.id = ep.user_id
JOIN users us ON u.id = us.user_id

LEFT JOIN follow f ON
  pc.user_id = f.following_user_id AND f.follower_user_id = $1
WHERE
  pc.post_id = $2
ORDER BY
  is_following_commenter DESC,
  pc.created_at DESC
  LIMIT $3 OFFSET $4
`

type RecommendCommentsParams struct {
	FollowerUserID uuid.UUID `json:"follower_user_id"`
	PostID         uuid.UUID `json:"post_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

type RecommendCommentsRow struct {
	CommentID            int32          `json:"comment_id"`
	CommentText          string         `json:"comment_text"`
	CommentCreatedAt     sql.NullTime   `json:"comment_created_at"`
	CommentUpdatedAt     sql.NullTime   `json:"comment_updated_at"`
	UserID               uuid.UUID      `json:"user_id"`
	CommenterUsername    sql.NullString `json:"commenter_username"`
	ImageUrl             sql.NullString `json:"image_url"`
	FirstName            sql.NullString `json:"first_name"`
	IsFollowingCommenter int32          `json:"is_following_commenter"`
}

func (q *Queries) RecommendComments(ctx context.Context, arg RecommendCommentsParams) ([]RecommendCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, recommendComments,
		arg.FollowerUserID,
		arg.PostID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecommendCommentsRow{}
	for rows.Next() {
		var i RecommendCommentsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.CommentText,
			&i.CommentCreatedAt,
			&i.CommentUpdatedAt,
			&i.UserID,
			&i.CommenterUsername,
			&i.ImageUrl,
			&i.FirstName,
			&i.IsFollowingCommenter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :exec
UPDATE "post_comments"
SET
  "comment_text" = $2,
  "updated_at" = NOW()
WHERE "id" = $1
`

type UpdateCommentParams struct {
	ID          int32  `json:"id"`
	CommentText string `json:"comment_text"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.ExecContext(ctx, updateComment, arg.ID, arg.CommentText)
	return err
}
