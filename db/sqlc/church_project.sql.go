// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: church_project.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const createChurchProject = `-- name: CreateChurchProject :exec
INSERT INTO church_projects (church_id, project_name, project_description, target_amount, donated_amount, start_date, end_date)
VALUES ($1, $2, $3, $4, 0.0, $5, $6)
`

type CreateChurchProjectParams struct {
	ChurchID           int32          `json:"church_id"`
	ProjectName        string         `json:"project_name"`
	ProjectDescription sql.NullString `json:"project_description"`
	TargetAmount       string         `json:"target_amount"`
	StartDate          sql.NullTime   `json:"start_date"`
	EndDate            sql.NullTime   `json:"end_date"`
}

func (q *Queries) CreateChurchProject(ctx context.Context, arg CreateChurchProjectParams) error {
	_, err := q.db.ExecContext(ctx, createChurchProject,
		arg.ChurchID,
		arg.ProjectName,
		arg.ProjectDescription,
		arg.TargetAmount,
		arg.StartDate,
		arg.EndDate,
	)
	return err
}

const createProjectsDonation = `-- name: CreateProjectsDonation :exec
INSERT INTO project_donations (project_id, user_id, donation_amount, donated_at)
VALUES ($1, $2, $3, now())
`

type CreateProjectsDonationParams struct {
	ProjectID      int32     `json:"project_id"`
	UserID         uuid.UUID `json:"user_id"`
	DonationAmount string    `json:"donation_amount"`
}

func (q *Queries) CreateProjectsDonation(ctx context.Context, arg CreateProjectsDonationParams) error {
	_, err := q.db.ExecContext(ctx, createProjectsDonation, arg.ProjectID, arg.UserID, arg.DonationAmount)
	return err
}

const getChurchProjectContributors = `-- name: GetChurchProjectContributors :many
With contributors AS (
    SELECT user_id,
           SUM(donation_amount) AS total_donation
    FROM project_donations
    WHERE project_id = $1
    GROUP BY user_id
)
SELECT 
       (
           SELECT JSON_AGG(
                      JSON_BUILD_OBJECT(
                          'user_id', c.user_id,
                          'total_donation', c.total_donation
                      )
                  )
           FROM contributors c
       ) AS contributors LIMIT $2 OFFSET $3
`

type GetChurchProjectContributorsParams struct {
	ProjectID int32 `json:"project_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

// TODO: Paginate
func (q *Queries) GetChurchProjectContributors(ctx context.Context, arg GetChurchProjectContributorsParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getChurchProjectContributors, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []json.RawMessage{}
	for rows.Next() {
		var contributors json.RawMessage
		if err := rows.Scan(&contributors); err != nil {
			return nil, err
		}
		items = append(items, contributors)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchProjectDetails = `-- name: GetChurchProjectDetails :many
WITH project_details AS (
    SELECT cp.id, cp.church_id, cp.project_name, cp.project_description, cp.target_amount, cp.donated_amount, cp.start_date, cp.end_date, cp.visibility, cp.completed, cp.created_at, cp.updated_at,
           COALESCE(SUM(pd.donation_amount), 0) AS total_donated_amount
    FROM church_projects cp
    LEFT JOIN project_donations pd ON cp.id = pd.project_id
    WHERE cp.id = $1
    GROUP BY cp.id
)
SELECT pd.id, pd.church_id, pd.project_name, pd.project_description, pd.target_amount, pd.donated_amount, pd.start_date, pd.end_date, pd.visibility, pd.completed, pd.created_at, pd.updated_at, pd.total_donated_amount
FROM project_details pd
`

type GetChurchProjectDetailsRow struct {
	ID                 int32          `json:"id"`
	ChurchID           int32          `json:"church_id"`
	ProjectName        string         `json:"project_name"`
	ProjectDescription sql.NullString `json:"project_description"`
	TargetAmount       string         `json:"target_amount"`
	DonatedAmount      string         `json:"donated_amount"`
	StartDate          sql.NullTime   `json:"start_date"`
	EndDate            sql.NullTime   `json:"end_date"`
	Visibility         sql.NullBool   `json:"visibility"`
	Completed          sql.NullBool   `json:"completed"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	TotalDonatedAmount interface{}    `json:"total_donated_amount"`
}

// , contributors AS (
//
//	SELECT user_id,
//	       SUM(donation_amount) AS total_donation
//	FROM project_donations
//	WHERE project_id = $1
//	GROUP BY user_id
//
// )
// ,
//
//	(
//	    SELECT JSON_AGG(
//	               JSON_BUILD_OBJECT(
//	                   'user_id', c.user_id,
//	                   'total_donation', c.total_donation
//	               )
//	           )
//	    FROM contributors c
//	) AS contributors
func (q *Queries) GetChurchProjectDetails(ctx context.Context, id int32) ([]GetChurchProjectDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChurchProjectDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChurchProjectDetailsRow{}
	for rows.Next() {
		var i GetChurchProjectDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChurchID,
			&i.ProjectName,
			&i.ProjectDescription,
			&i.TargetAmount,
			&i.DonatedAmount,
			&i.StartDate,
			&i.EndDate,
			&i.Visibility,
			&i.Completed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalDonatedAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchProjectDetailsOld = `-- name: GetChurchProjectDetailsOld :many
SELECT cp.id, cp.church_id, cp.project_name, cp.project_description, cp.target_amount, cp.donated_amount, cp.start_date, cp.end_date, cp.visibility, cp.completed, cp.created_at, cp.updated_at,
       COALESCE(SUM(pd.donation_amount), 0) AS total_donated_amount,
       (
           SELECT JSON_AGG(
                      JSON_BUILD_OBJECT(
                          'user_id', pd.user_id,
                          'total_donation', SUM(pd.donation_amount)
                      )
                  )
           FROM project_donations pd
           WHERE pd.project_id = cp.id
           GROUP BY pd.user_id
       ) AS contributors
FROM church_projects cp
LEFT JOIN project_donations pd ON cp.id = pd.project_id
WHERE cp.id = $1
GROUP BY cp.id
`

type GetChurchProjectDetailsOldRow struct {
	ID                 int32           `json:"id"`
	ChurchID           int32           `json:"church_id"`
	ProjectName        string          `json:"project_name"`
	ProjectDescription sql.NullString  `json:"project_description"`
	TargetAmount       string          `json:"target_amount"`
	DonatedAmount      string          `json:"donated_amount"`
	StartDate          sql.NullTime    `json:"start_date"`
	EndDate            sql.NullTime    `json:"end_date"`
	Visibility         sql.NullBool    `json:"visibility"`
	Completed          sql.NullBool    `json:"completed"`
	CreatedAt          sql.NullTime    `json:"created_at"`
	UpdatedAt          sql.NullTime    `json:"updated_at"`
	TotalDonatedAmount interface{}     `json:"total_donated_amount"`
	Contributors       json.RawMessage `json:"contributors"`
}

func (q *Queries) GetChurchProjectDetailsOld(ctx context.Context, id int32) ([]GetChurchProjectDetailsOldRow, error) {
	rows, err := q.db.QueryContext(ctx, getChurchProjectDetailsOld, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChurchProjectDetailsOldRow{}
	for rows.Next() {
		var i GetChurchProjectDetailsOldRow
		if err := rows.Scan(
			&i.ID,
			&i.ChurchID,
			&i.ProjectName,
			&i.ProjectDescription,
			&i.TargetAmount,
			&i.DonatedAmount,
			&i.StartDate,
			&i.EndDate,
			&i.Visibility,
			&i.Completed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalDonatedAmount,
			&i.Contributors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchProjectDetailsWithContributors = `-- name: GetChurchProjectDetailsWithContributors :many
WITH project_details AS (
    SELECT cp.id, cp.church_id, cp.project_name, cp.project_description, cp.target_amount, cp.donated_amount, cp.start_date, cp.end_date, cp.visibility, cp.completed, cp.created_at, cp.updated_at,
           COALESCE(SUM(pd.donation_amount), 0) AS total_donated_amount
    FROM church_projects cp
    LEFT JOIN project_donations pd ON cp.id = pd.project_id
    WHERE cp.id = $1
    GROUP BY cp.id
), contributors AS (
    SELECT user_id,
           SUM(donation_amount) AS total_donation
    FROM project_donations
    WHERE project_id = $1
    GROUP BY user_id
)
SELECT pd.id, pd.church_id, pd.project_name, pd.project_description, pd.target_amount, pd.donated_amount, pd.start_date, pd.end_date, pd.visibility, pd.completed, pd.created_at, pd.updated_at, pd.total_donated_amount,
       (
           SELECT JSON_AGG(
                      JSON_BUILD_OBJECT(
                          'user_id', c.user_id,
                          'total_donation', c.total_donation
                      )
                  )
           FROM contributors c
       ) AS contributors
FROM project_details pd
`

type GetChurchProjectDetailsWithContributorsRow struct {
	ID                 int32           `json:"id"`
	ChurchID           int32           `json:"church_id"`
	ProjectName        string          `json:"project_name"`
	ProjectDescription sql.NullString  `json:"project_description"`
	TargetAmount       string          `json:"target_amount"`
	DonatedAmount      string          `json:"donated_amount"`
	StartDate          sql.NullTime    `json:"start_date"`
	EndDate            sql.NullTime    `json:"end_date"`
	Visibility         sql.NullBool    `json:"visibility"`
	Completed          sql.NullBool    `json:"completed"`
	CreatedAt          sql.NullTime    `json:"created_at"`
	UpdatedAt          sql.NullTime    `json:"updated_at"`
	TotalDonatedAmount interface{}     `json:"total_donated_amount"`
	Contributors       json.RawMessage `json:"contributors"`
}

func (q *Queries) GetChurchProjectDetailsWithContributors(ctx context.Context, id int32) ([]GetChurchProjectDetailsWithContributorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChurchProjectDetailsWithContributors, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChurchProjectDetailsWithContributorsRow{}
	for rows.Next() {
		var i GetChurchProjectDetailsWithContributorsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChurchID,
			&i.ProjectName,
			&i.ProjectDescription,
			&i.TargetAmount,
			&i.DonatedAmount,
			&i.StartDate,
			&i.EndDate,
			&i.Visibility,
			&i.Completed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalDonatedAmount,
			&i.Contributors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchProjectTopContributors = `-- name: GetChurchProjectTopContributors :many
SELECT user_id, SUM(donation_amount) AS total_donation
FROM project_donations
WHERE project_id = $1
GROUP BY user_id
ORDER BY total_donation DESC
LIMIT 10
`

type GetChurchProjectTopContributorsRow struct {
	UserID        uuid.UUID `json:"user_id"`
	TotalDonation int64     `json:"total_donation"`
}

// ! Top contributors
func (q *Queries) GetChurchProjectTopContributors(ctx context.Context, projectID int32) ([]GetChurchProjectTopContributorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChurchProjectTopContributors, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChurchProjectTopContributorsRow{}
	for rows.Next() {
		var i GetChurchProjectTopContributorsRow
		if err := rows.Scan(&i.UserID, &i.TotalDonation); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchProjectTrend = `-- name: GetChurchProjectTrend :many
SELECT DATE_TRUNC('month', donated_at) AS month,
       SUM(donation_amount) AS total_donation
FROM project_donations
WHERE project_id = $1
GROUP BY month
ORDER BY month
`

type GetChurchProjectTrendRow struct {
	Month         int64 `json:"month"`
	TotalDonation int64 `json:"total_donation"`
}

// ! Donation trends
func (q *Queries) GetChurchProjectTrend(ctx context.Context, projectID int32) ([]GetChurchProjectTrendRow, error) {
	rows, err := q.db.QueryContext(ctx, getChurchProjectTrend, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChurchProjectTrendRow{}
	for rows.Next() {
		var i GetChurchProjectTrendRow
		if err := rows.Scan(&i.Month, &i.TotalDonation); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChurchProjects = `-- name: GetChurchProjects :many
SELECT cp.id, cp.church_id, cp.project_name, cp.project_description, cp.target_amount, cp.donated_amount, cp.start_date, cp.end_date, cp.visibility, cp.completed, cp.created_at, cp.updated_at, COALESCE(SUM(pd.donation_amount), 0) AS total_donated_amount
FROM church_projects cp
LEFT JOIN project_donations pd ON cp.id = pd.project_id
WHERE cp.church_id = $1
GROUP BY cp.id
`

type GetChurchProjectsRow struct {
	ID                 int32          `json:"id"`
	ChurchID           int32          `json:"church_id"`
	ProjectName        string         `json:"project_name"`
	ProjectDescription sql.NullString `json:"project_description"`
	TargetAmount       string         `json:"target_amount"`
	DonatedAmount      string         `json:"donated_amount"`
	StartDate          sql.NullTime   `json:"start_date"`
	EndDate            sql.NullTime   `json:"end_date"`
	Visibility         sql.NullBool   `json:"visibility"`
	Completed          sql.NullBool   `json:"completed"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	TotalDonatedAmount interface{}    `json:"total_donated_amount"`
}

func (q *Queries) GetChurchProjects(ctx context.Context, churchID int32) ([]GetChurchProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChurchProjects, churchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChurchProjectsRow{}
	for rows.Next() {
		var i GetChurchProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChurchID,
			&i.ProjectName,
			&i.ProjectDescription,
			&i.TargetAmount,
			&i.DonatedAmount,
			&i.StartDate,
			&i.EndDate,
			&i.Visibility,
			&i.Completed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalDonatedAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markChurchProjectAsCompleted = `-- name: MarkChurchProjectAsCompleted :exec
UPDATE church_projects
SET completed = TRUE,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkChurchProjectAsCompleted(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markChurchProjectAsCompleted, id)
	return err
}

const updateChurchProject = `-- name: UpdateChurchProject :exec
UPDATE church_projects
SET
    project_name = COALESCE($1,project_name),
    project_description = COALESCE($2,project_description),
    target_amount = COALESCE($3,target_amount),
    start_date = COALESCE($4,start_date),
    end_date = COALESCE($5,end_date),
    visibility = COALESCE($6,visibility),
    updated_at = NOW()
WHERE
    id = $7
`

type UpdateChurchProjectParams struct {
	ProjectName        sql.NullString `json:"project_name"`
	ProjectDescription sql.NullString `json:"project_description"`
	TargetAmount       sql.NullString `json:"target_amount"`
	StartDate          sql.NullTime   `json:"start_date"`
	EndDate            sql.NullTime   `json:"end_date"`
	Visibility         sql.NullBool   `json:"visibility"`
	ID                 int32          `json:"id"`
}

func (q *Queries) UpdateChurchProject(ctx context.Context, arg UpdateChurchProjectParams) error {
	_, err := q.db.ExecContext(ctx, updateChurchProject,
		arg.ProjectName,
		arg.ProjectDescription,
		arg.TargetAmount,
		arg.StartDate,
		arg.EndDate,
		arg.Visibility,
		arg.ID,
	)
	return err
}
