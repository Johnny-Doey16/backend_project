// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: htags_bkmk_mod.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
)

const addToModerationQueue = `-- name: AddToModerationQueue :one
INSERT INTO "moderation_queue" ("user_id", "post_id", "report_reason", "status") VALUES ($1, $2, $3, $4) RETURNING id, user_id, post_id, report_reason, status, created_at
`

type AddToModerationQueueParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	PostID       uuid.UUID      `json:"post_id"`
	ReportReason sql.NullString `json:"report_reason"`
	Status       sql.NullString `json:"status"`
}

// TODO: Admin functions
func (q *Queries) AddToModerationQueue(ctx context.Context, arg AddToModerationQueueParams) (ModerationQueue, error) {
	row := q.db.QueryRowContext(ctx, addToModerationQueue,
		arg.UserID,
		arg.PostID,
		arg.ReportReason,
		arg.Status,
	)
	var i ModerationQueue
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.ReportReason,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const blockUserSM = `-- name: BlockUserSM :one
INSERT INTO "blocked_users" ("blocking_user_id", "blocked_user_id", "reason") VALUES ($1, $2, $3) RETURNING id, blocking_user_id, blocked_user_id, reason, created_at
`

type BlockUserSMParams struct {
	BlockingUserID uuid.UUID      `json:"blocking_user_id"`
	BlockedUserID  uuid.UUID      `json:"blocked_user_id"`
	Reason         sql.NullString `json:"reason"`
}

func (q *Queries) BlockUserSM(ctx context.Context, arg BlockUserSMParams) (BlockedUser, error) {
	row := q.db.QueryRowContext(ctx, blockUserSM, arg.BlockingUserID, arg.BlockedUserID, arg.Reason)
	var i BlockedUser
	err := row.Scan(
		&i.ID,
		&i.BlockingUserID,
		&i.BlockedUserID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const createBookmark = `-- name: CreateBookmark :exec
INSERT INTO "bookmarks" ("user_id", "post_id") VALUES ($1, $2)
`

type CreateBookmarkParams struct {
	UserID uuid.UUID `json:"user_id"`
	PostID uuid.UUID `json:"post_id"`
}

func (q *Queries) CreateBookmark(ctx context.Context, arg CreateBookmarkParams) error {
	_, err := q.db.ExecContext(ctx, createBookmark, arg.UserID, arg.PostID)
	return err
}

const createHashtag = `-- name: CreateHashtag :one
INSERT INTO "hashtag" ("hash_tag") VALUES ($1) RETURNING id, hash_tag
`

func (q *Queries) CreateHashtag(ctx context.Context, hashTag sql.NullString) (Hashtag, error) {
	row := q.db.QueryRowContext(ctx, createHashtag, hashTag)
	var i Hashtag
	err := row.Scan(&i.ID, &i.HashTag)
	return i, err
}

const createPostHashtag = `-- name: CreatePostHashtag :one
INSERT INTO "post_hashtag" ("post_id", "hashtag_id") VALUES ($1, $2) RETURNING id, post_id, hashtag_id
`

type CreatePostHashtagParams struct {
	PostID    uuid.UUID     `json:"post_id"`
	HashtagID sql.NullInt32 `json:"hashtag_id"`
}

func (q *Queries) CreatePostHashtag(ctx context.Context, arg CreatePostHashtagParams) (PostHashtag, error) {
	row := q.db.QueryRowContext(ctx, createPostHashtag, arg.PostID, arg.HashtagID)
	var i PostHashtag
	err := row.Scan(&i.ID, &i.PostID, &i.HashtagID)
	return i, err
}

const deleteBookmark = `-- name: DeleteBookmark :one
DELETE FROM "bookmarks" WHERE "id" = $1 RETURNING id, user_id, post_id, created_at
`

func (q *Queries) DeleteBookmark(ctx context.Context, id int32) (Bookmark, error) {
	row := q.db.QueryRowContext(ctx, deleteBookmark, id)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteHashtag = `-- name: DeleteHashtag :exec
DELETE FROM "hashtag" WHERE "id" = $1
`

func (q *Queries) DeleteHashtag(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteHashtag, id)
	return err
}

const deletePostHashtag = `-- name: DeletePostHashtag :exec
DELETE FROM "post_hashtag" WHERE "id" = $1
`

func (q *Queries) DeletePostHashtag(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePostHashtag, id)
	return err
}

const deleteReportedPost = `-- name: DeleteReportedPost :exec
DELETE FROM "reported_posts" WHERE "id" = $1
`

func (q *Queries) DeleteReportedPost(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteReportedPost, id)
	return err
}

const getBlockedUsersByBlocker = `-- name: GetBlockedUsersByBlocker :many
SELECT id, blocking_user_id, blocked_user_id, reason, created_at FROM "blocked_users" WHERE "blocking_user_id" = $1
`

func (q *Queries) GetBlockedUsersByBlocker(ctx context.Context, blockingUserID uuid.UUID) ([]BlockedUser, error) {
	rows, err := q.db.QueryContext(ctx, getBlockedUsersByBlocker, blockingUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BlockedUser{}
	for rows.Next() {
		var i BlockedUser
		if err := rows.Scan(
			&i.ID,
			&i.BlockingUserID,
			&i.BlockedUserID,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHashtag = `-- name: GetHashtag :one
SELECT id, hash_tag FROM "hashtag" WHERE "id" = $1 LIMIT 1
`

func (q *Queries) GetHashtag(ctx context.Context, id int32) (Hashtag, error) {
	row := q.db.QueryRowContext(ctx, getHashtag, id)
	var i Hashtag
	err := row.Scan(&i.ID, &i.HashTag)
	return i, err
}

const getModerationQueue = `-- name: GetModerationQueue :many
SELECT id, user_id, post_id, report_reason, status, created_at FROM "moderation_queue" WHERE "status" = $1
`

func (q *Queries) GetModerationQueue(ctx context.Context, status sql.NullString) ([]ModerationQueue, error) {
	rows, err := q.db.QueryContext(ctx, getModerationQueue, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ModerationQueue{}
	for rows.Next() {
		var i ModerationQueue
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.ReportReason,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostHashtags = `-- name: GetPostHashtags :many
SELECT id, post_id, hashtag_id FROM "post_hashtag" WHERE "post_id" = $1
`

func (q *Queries) GetPostHashtags(ctx context.Context, postID uuid.UUID) ([]PostHashtag, error) {
	rows, err := q.db.QueryContext(ctx, getPostHashtags, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PostHashtag{}
	for rows.Next() {
		var i PostHashtag
		if err := rows.Scan(&i.ID, &i.PostID, &i.HashtagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportedPosts = `-- name: GetReportedPosts :many
SELECT id, post_id, user_id, reason, created_at FROM "reported_posts"
`

// TODO: Admin functions
func (q *Queries) GetReportedPosts(ctx context.Context) ([]ReportedPost, error) {
	rows, err := q.db.QueryContext(ctx, getReportedPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReportedPost{}
	for rows.Next() {
		var i ReportedPost
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.UserID,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBookmarks = `-- name: GetUserBookmarks :many

SELECT
    p.id AS post_id,
    p.content,
    p.created_at AS post_created_at,
    p.deleted_at AS post_deleted_at,
    p.suspended_at AS post_suspended_at,
    b.created_at AS bookmarked_at,
    p.user_id AS author_user_id,
    u.username AS author_username,
    us.first_name AS author_first_name,
    ep.image_url AS author_image_url,
    json_agg(pi.image_url) AS post_image_urls,
    pm.likes,
    pm.views,
    pm.comments,
    pm.reposts,
    EXISTS (
        SELECT 1
        FROM "likes" l
        WHERE l.post_id = p.id AND l.user_id = $1
    ) AS liked
FROM
    "bookmarks" b
JOIN "posts" p ON b.post_id = p.id
JOIN "authentications" u ON p.user_id = u.id
JOIN "users" us ON u.id = us.user_id
JOIN "entity_profiles" ep ON u.id = ep.user_id
LEFT JOIN "posts_images" pi ON p.id = pi.post_id
LEFT JOIN "posts_metrics" pm ON p.id = pm.post_id
WHERE
    b.user_id = $1 AND
    p.suspended_at IS NULL AND
    p.deleted_at IS NULL
GROUP BY
    p.id, b.created_at, p.content, p.created_at, p.user_id, u.username, us.first_name, ep.image_url, pm.likes, pm.views, pm.comments, pm.reposts
ORDER BY bookmarked_at DESC
LIMIT $2 OFFSET $3
`

type GetUserBookmarksParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetUserBookmarksRow struct {
	PostID          uuid.UUID       `json:"post_id"`
	Content         string          `json:"content"`
	PostCreatedAt   sql.NullTime    `json:"post_created_at"`
	PostDeletedAt   sql.NullTime    `json:"post_deleted_at"`
	PostSuspendedAt sql.NullTime    `json:"post_suspended_at"`
	BookmarkedAt    sql.NullTime    `json:"bookmarked_at"`
	AuthorUserID    uuid.UUID       `json:"author_user_id"`
	AuthorUsername  sql.NullString  `json:"author_username"`
	AuthorFirstName sql.NullString  `json:"author_first_name"`
	AuthorImageUrl  sql.NullString  `json:"author_image_url"`
	PostImageUrls   json.RawMessage `json:"post_image_urls"`
	Likes           sql.NullInt32   `json:"likes"`
	Views           sql.NullInt32   `json:"views"`
	Comments        sql.NullInt32   `json:"comments"`
	Reposts         sql.NullInt32   `json:"reposts"`
	Liked           bool            `json:"liked"`
}

// ON CONFLICT DO NOTHING;
func (q *Queries) GetUserBookmarks(ctx context.Context, arg GetUserBookmarksParams) ([]GetUserBookmarksRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBookmarks, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserBookmarksRow{}
	for rows.Next() {
		var i GetUserBookmarksRow
		if err := rows.Scan(
			&i.PostID,
			&i.Content,
			&i.PostCreatedAt,
			&i.PostDeletedAt,
			&i.PostSuspendedAt,
			&i.BookmarkedAt,
			&i.AuthorUserID,
			&i.AuthorUsername,
			&i.AuthorFirstName,
			&i.AuthorImageUrl,
			&i.PostImageUrls,
			&i.Likes,
			&i.Views,
			&i.Comments,
			&i.Reposts,
			&i.Liked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFromModerationQueue = `-- name: RemoveFromModerationQueue :exec
DELETE FROM "moderation_queue" WHERE "id" = $1
`

func (q *Queries) RemoveFromModerationQueue(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, removeFromModerationQueue, id)
	return err
}

const reportPost = `-- name: ReportPost :one
INSERT INTO "reported_posts" ("post_id", "user_id", "reason") VALUES ($1, $2, $3) RETURNING id, post_id, user_id, reason, created_at
`

type ReportPostParams struct {
	PostID uuid.UUID      `json:"post_id"`
	UserID uuid.UUID      `json:"user_id"`
	Reason sql.NullString `json:"reason"`
}

func (q *Queries) ReportPost(ctx context.Context, arg ReportPostParams) (ReportedPost, error) {
	row := q.db.QueryRowContext(ctx, reportPost, arg.PostID, arg.UserID, arg.Reason)
	var i ReportedPost
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.UserID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const unblockUser = `-- name: UnblockUser :exec
DELETE FROM "blocked_users" WHERE "id" = $1
`

func (q *Queries) UnblockUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, unblockUser, id)
	return err
}

const updateHashtag = `-- name: UpdateHashtag :exec
UPDATE "hashtag" SET "hash_tag" = $2 WHERE "id" = $1
`

type UpdateHashtagParams struct {
	ID      int32          `json:"id"`
	HashTag sql.NullString `json:"hash_tag"`
}

func (q *Queries) UpdateHashtag(ctx context.Context, arg UpdateHashtagParams) error {
	_, err := q.db.ExecContext(ctx, updateHashtag, arg.ID, arg.HashTag)
	return err
}

const updateModerationQueueStatus = `-- name: UpdateModerationQueueStatus :exec
UPDATE "moderation_queue" SET "status" = $2 WHERE "id" = $1
`

type UpdateModerationQueueStatusParams struct {
	ID     int32          `json:"id"`
	Status sql.NullString `json:"status"`
}

func (q *Queries) UpdateModerationQueueStatus(ctx context.Context, arg UpdateModerationQueueStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateModerationQueueStatus, arg.ID, arg.Status)
	return err
}
