// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: denomination.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createDenomination = `-- name: CreateDenomination :exec
INSERT INTO "denominations" ("name") VALUES ($1)
`

func (q *Queries) CreateDenomination(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createDenomination, name)
	return err
}

const createDenominationForUser = `-- name: CreateDenominationForUser :exec
INSERT INTO "user_denomination_membership" (user_id, denomination_id, join_date) VALUES ($1, $2, NOW())
`

type CreateDenominationForUserParams struct {
	UserID         uuid.UUID `json:"user_id"`
	DenominationID int32     `json:"denomination_id"`
}

func (q *Queries) CreateDenominationForUser(ctx context.Context, arg CreateDenominationForUserParams) error {
	_, err := q.db.ExecContext(ctx, createDenominationForUser, arg.UserID, arg.DenominationID)
	return err
}

const createDenominationForUserOld = `-- name: CreateDenominationForUserOld :exec
WITH updated_users AS (
  UPDATE users
  SET denomination_id = $2, last_denomination_change = NOW()
  WHERE user_id = $1
    AND users.denomination_id IS DISTINCT FROM $2
    AND (users.last_denomination_change IS NULL OR users.last_denomination_change < NOW() - INTERVAL '1 year')
  RETURNING id
)
INSERT INTO user_denomination_membership (user_id, denomination_id, join_date, active)
SELECT $1, $2, NOW(), TRUE
FROM updated_users
WHERE NOT EXISTS (
  SELECT 1 FROM user_denomination_membership
  WHERE user_id = $1 AND denomination_id = $2 AND active
)
AND (
  SELECT COUNT(*)
  FROM user_denomination_membership
  WHERE user_id = $1 AND active AND join_date >= NOW() - INTERVAL '1 year'
) = 0
`

type CreateDenominationForUserOldParams struct {
	UserID         uuid.UUID `json:"user_id"`
	DenominationID int32     `json:"denomination_id"`
}

func (q *Queries) CreateDenominationForUserOld(ctx context.Context, arg CreateDenominationForUserOldParams) error {
	_, err := q.db.ExecContext(ctx, createDenominationForUserOld, arg.UserID, arg.DenominationID)
	return err
}

const getDenominationList = `-- name: GetDenominationList :many
SELECT id, name FROM denominations
`

func (q *Queries) GetDenominationList(ctx context.Context) ([]Denomination, error) {
	rows, err := q.db.QueryContext(ctx, getDenominationList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Denomination{}
	for rows.Next() {
		var i Denomination
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAndMembership = `-- name: GetUserAndMembership :one
SELECT u.id, u.user_id, u.first_name, u.last_name, u.last_denomination_change, u.last_church_change, u.denomination_id, u.church_id, m.id, m.user_id, m.denomination_id, m.join_date, m.leave_date, m.active
FROM users u
LEFT JOIN user_denomination_membership m ON u.user_id = m.user_id AND m.active
WHERE u.user_id = $1
ORDER BY m.join_date DESC
LIMIT 1
`

type GetUserAndMembershipRow struct {
	ID                     int32          `json:"id"`
	UserID                 uuid.UUID      `json:"user_id"`
	FirstName              sql.NullString `json:"first_name"`
	LastName               sql.NullString `json:"last_name"`
	LastDenominationChange sql.NullTime   `json:"last_denomination_change"`
	LastChurchChange       sql.NullTime   `json:"last_church_change"`
	DenominationID         sql.NullInt32  `json:"denomination_id"`
	ChurchID               sql.NullInt32  `json:"church_id"`
	ID_2                   sql.NullInt32  `json:"id_2"`
	UserID_2               uuid.NullUUID  `json:"user_id_2"`
	DenominationID_2       sql.NullInt32  `json:"denomination_id_2"`
	JoinDate               sql.NullTime   `json:"join_date"`
	LeaveDate              sql.NullTime   `json:"leave_date"`
	Active                 sql.NullBool   `json:"active"`
}

func (q *Queries) GetUserAndMembership(ctx context.Context, userID uuid.UUID) (GetUserAndMembershipRow, error) {
	row := q.db.QueryRowContext(ctx, getUserAndMembership, userID)
	var i GetUserAndMembershipRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.LastDenominationChange,
		&i.LastChurchChange,
		&i.DenominationID,
		&i.ChurchID,
		&i.ID_2,
		&i.UserID_2,
		&i.DenominationID_2,
		&i.JoinDate,
		&i.LeaveDate,
		&i.Active,
	)
	return i, err
}

const getUserDenominationMembership = `-- name: GetUserDenominationMembership :one
SELECT id, user_id, denomination_id, join_date, leave_date, active FROM user_denomination_membership
WHERE user_id = $1 AND denomination_id = $2 AND active
ORDER BY join_date DESC
LIMIT 1
`

type GetUserDenominationMembershipParams struct {
	UserID         uuid.UUID `json:"user_id"`
	DenominationID int32     `json:"denomination_id"`
}

func (q *Queries) GetUserDenominationMembership(ctx context.Context, arg GetUserDenominationMembershipParams) (UserDenominationMembership, error) {
	row := q.db.QueryRowContext(ctx, getUserDenominationMembership, arg.UserID, arg.DenominationID)
	var i UserDenominationMembership
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DenominationID,
		&i.JoinDate,
		&i.LeaveDate,
		&i.Active,
	)
	return i, err
}

const leaveDenomination = `-- name: LeaveDenomination :exec
UPDATE user_denomination_membership
SET active = FALSE, leave_date = NOW()
WHERE user_id = $1 AND active
  AND (join_date < NOW() - INTERVAL '1 year')
`

func (q *Queries) LeaveDenomination(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, leaveDenomination, userID)
	return err
}

const updateDenominationForUser = `-- name: UpdateDenominationForUser :exec
WITH deactivated AS (
  UPDATE user_denomination_membership
  SET active = FALSE, leave_date = NOW()
  WHERE user_denomination_membership.user_id = $2 AND active
  RETURNING user_denomination_membership.user_id, denomination_id, join_date
),
can_change AS (
  SELECT user_id, denomination_id, join_date
  FROM deactivated
  WHERE join_date <= NOW() - INTERVAL '1 year'
),
updated_users AS (
  UPDATE users
  SET denomination_id = $1, last_denomination_change = NOW()
  FROM can_change
  WHERE users.user_id = can_change.user_id
    AND users.denomination_id != can_change.denomination_id
  RETURNING users.user_id
)
INSERT INTO user_denomination_membership (user_id, denomination_id, join_date, active)
SELECT user_id, $1, NOW(), TRUE
FROM can_change
WHERE NOT EXISTS (
  SELECT 1
  FROM updated_users
  WHERE updated_users.user_id = can_change.user_id
)
`

type UpdateDenominationForUserParams struct {
	DenominationID int32     `json:"denomination_id"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateDenominationForUser(ctx context.Context, arg UpdateDenominationForUserParams) error {
	_, err := q.db.ExecContext(ctx, updateDenominationForUser, arg.DenominationID, arg.UserID)
	return err
}

const updateDenominationForUserOld = `-- name: UpdateDenominationForUserOld :exec
WITH deactivated AS (
  UPDATE user_denomination_membership
  SET active = FALSE, leave_date = NOW()
  WHERE user_id = $2 AND active
  RETURNING user_id
),
updated_users AS (
  UPDATE users
  SET denomination_id = $1, last_denomination_change = NOW()
  FROM deactivated
  WHERE users.user_id = $2
    AND users.denomination_id IS DISTINCT FROM $1
    AND (users.last_denomination_change IS NULL OR users.last_denomination_change < NOW() - INTERVAL '1 year')
  RETURNING id
)
INSERT INTO user_denomination_membership (user_id, denomination_id, join_date, active)
SELECT $2, $1, NOW(), TRUE
FROM updated_users
`

type UpdateDenominationForUserOldParams struct {
	DenominationID int32     `json:"denomination_id"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateDenominationForUserOld(ctx context.Context, arg UpdateDenominationForUserOldParams) error {
	_, err := q.db.ExecContext(ctx, updateDenominationForUserOld, arg.DenominationID, arg.UserID)
	return err
}
