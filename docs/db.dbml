Project diivix_auth {
  database_type: 'PostgreSQL'
  Note: '''
  # Diivix DB Schema
  **markdown content here**
  '''
}

// * AUTH/USERS

Table users {
  id uuid [pk, not null]
  email varchar [unique, not null]
  username varchar [unique]
  phone varchar
  password_hash varchar [not null]
  created_at timestamptz [default: `now()`]
  updated_at timestamptz
  is_suspended boolean [default: false]
  is_deleted boolean [default: false]
  is_verified boolean [default: false]
  is_email_verified boolean [default: false]
  deleted_at timestamptz
  verified_at timestamptz
  suspended_at timestamptz
  login_attempts int [default: 0]
  password_last_changed timestamptz
  lockout_duration int [default: 60] // minutes
  lockout_until timestamptz
  is_mfa_enabled boolean DEFAULT false
  Indexes {
    (email, username, created_at, updated_at)
  }
}






Table user_profiles {
  id int [pk, increment]  
  user_id uuid [ref: > users.id, not null]
  // updated_at timestamptz
  image_url varchar
  following_count int [default: 0]
  followers_count int [default: 0]
  entity_type varchar [not null]

  posts_count int [default: 0]
  header_image_url varchar
  about varchar
  website varchar
}

Table roles {
  id int [pk, increment]
  name varchar
}

Table user_roles {
  id int [pk, increment]
  user_id uuid [ref: > users.id, not null]
  role_id int [ref: > roles.id, not null]
  Indexes{
    (role_id) 
  }
}

// Email verification requests
Table email_verification_requests {
  id bigserial [pk, increment]
  user_id uuid [ref: > users.id, not null]
  email varchar [not null]
  token varchar [not null, unique]
  is_verified boolean [default: false]
  created_at timestamptz [default: `now()`]
  expires_at timestamptz [default: `now() + interval 15 minutes`]
  Indexes{
    (user_id, token, email, created_at)
  }
}

Table user_logins {
  id int [pk, increment]
  user_id uuid [ref: > users.id]
  login_at timestamptz [default: `now()`]
  ip_address inet
  user_agent varchar
  Indexes{
    (user_id, login_at) 
  }
}

Table sessions {
  id uuid [pk, not null]
  user_id uuid [ref: > users.id]
  refresh_token varchar [not null, unique]
  refresh_token_exp timestamptz [not null]
  created_at timestamptz [default: `now()`]
  updated_at timestamptz // Time when the session was last updated (e.g., token rotation)
  invalidated_at timestamptz // Time when the session was invalidated, if at all
  last_active_at timestamptz // Last time the user was active within the session
  blocked_at timestamptz // Time when the session was blocked, if at all
  user_agent text [not null]
  ip_address inet [not null]
  Indexes{
    (user_id, refresh_token_exp, updated_at) 
  }
}


Table password_reset_requests {
  id int [pk, increment]
  user_id uuid [ref: > users.id, not null] 
  email varchar [not null]
  token varchar [not null, unique]
  used boolean [default: false]
  created_at timestamptz [default: `now()`]
  expires_at timestamptz
  Indexes{
    (user_id, token) 
  }
}


Table account_recovery_requests {
  id int [pk, increment]
  user_id uuid [ref: > users.id, not null] 
  email varchar [not null]
  used boolean [default: false]
  recovery_token varchar [unique, not null]
  requested_at timestamptz [default: `now()`]
  expires_at timestamptz [not null]
  completed_at timestamptz
  Indexes{
    (user_id, recovery_token)
  }
}


Table two_factor_secrets {
  id int [pk, increment]
  user_id uuid [ref: > users.id, not null] //,unique]
  secret_key varchar [not null, note: 'Encrypted']
  is_active boolean DEFAULT true
}

Table two_factor_revocation {
  id int [pk, increment]
  user_id uuid [not null, ref: > users.id]
  revoked_at timestamptz
  revocation_reason varchar [nullable]
  revoked_by uuid [nullable, ref: > users.id]
}

Table two_factor_backup_codes {
  id int [pk, increment]
  user_id uuid [ref: > users.id, not null]
  code varchar [not null, note: 'Encrypted']
  used boolean DEFAULT false
}

Table change_identifier_requests {
    id int [pk, increment]
    user_id uuid [ref: > users.id]
    identifier varchar [not null]
    token varchar [not null, unique]
    type varchar [not null]
    used boolean [default: false]
    created_at timestamptz [default: `now()`]
    expires_at timestamptz
    Indexes{
        (user_id, identifier, token, expires_at) 
    }
}



// ! Start of unused

// Login failures  
Table login_failures {
  id int [pk, increment]
  user_id uuid [ref: > users.id]
  timestamp timestamptz
  user_agent varchar
  ip_address inet
  Indexes{
    (user_id, timestamp) 
  }
}

// Banned users
Table banned_users {
  id int [pk, increment] 
  user_id uuid [ref: > users.id]
  banned_at timestamptz
  reason varchar
  Indexes{
    (user_id) 
  }
}

Table security_questions {
  id int [pk, increment]
  user_id uuid [ref: > users.id]
  question varchar
  answer varchar
  expired_at timestamptz
}

Table social_providers {
  id int [pk, increment]
  name varchar [unique]
  api_key varchar
  oauth_settings json
}

Table social_provider_users {
  id int [pk, increment]
  provider_id int [ref: > social_providers.id]
  provider_user_id varchar
  user_id uuid [ref: > users.id] 
  access_token varchar
  refresh_token varchar
  Indexes{
    (provider_id, provider_user_id) 
  }
}


Table audit_logs {
  id int [pk, increment]
  user_id uuid [ref: > users.id] 
  action varchar
  created_at timestamptz [default: `now()`]
  updated_at timestamptz
  Indexes{
    (user_id, updated_at, created_at)
  }
}

Table user_preferences {
  user_id uuid [ref: > users.id]
  preferences json // or break into columns
}

// Notifications
Table notifications {
  id int [pk, increment] 
  user_id uuid [ref: > users.id]
  title varchar
  action varchar
  content varchar
  details json
  read_at timestamptz
  created_at timestamptz [default: `now()`]
  Indexes{
    (user_id, created_at, read_at) 
  }
}


// API keys
Table api_keys {
  id int [pk, increment]
  user_id uuid [ref: > users.id]
  key varchar [unique]
  permissions json
  created_at timestamptz [default: `now()`]
  updated_at timestamptz 
  last_used_at timestamptz
  is_active boolean
  is_deleted boolean
  Indexes{
    (user_id, key, updated_at, created_at)
  }
}

Table user_api_keys {
  user_id uuid [ref: > users.id]
  api_key_id int [ref: > api_keys.id]
  Indexes{
    (user_id, api_key_id)
  }
}
// ? End of used

// * POSTS
Table posts {
  id uuid [pk]
  user_id uuid [ref: > users.id, not null] 
  content varchar [not null]
  total_images int [default: 0]
  created_at timestamptz [default: `now()`]
  updated_at timestamptz
  deleted_at timestamptz
  Indexes{
    (user_id, id, created_at)
  }
}

Table posts_images {
  id int [pk, increment]
  post_id uuid [ref: > posts.id, not null] 
  image_url varchar
  caption varchar
  Indexes{
    (post_id, id, image_url)
  }
}

Table hashtag {
  id int [pk, increment]
  hash_tag varchar
  Indexes{
    (hash_tag, id)
  }
}

Table post_hashtag {
  id int [pk, increment]
  post_id uuid [ref: > posts.id]
  hashtag_id uuid [ref: > hashtag.id]
  Indexes{
    (hashtag_id, id, post_id)
  }
}

Table post_comments {
  id int [pk, increment]
  user_id uuid [ref: > users.id] 
  post_id uuid [ref: > posts.id]
  comment_text varchar
  created_at timestamptz [default: `now()`]
  updated_at timestamptz
  Indexes{
    (user_id, id, post_id)
  }
}

Table repost {
  id int [pk, increment]
  user_id uuid [ref: > users.id] 
  original_post_id uuid [ref: > posts.id]
  created_at timestamptz [default: `now()`]
  Indexes{
    (user_id, id, original_post_id)
  }
}


Table likes {
  id int [pk, increment]
  user_id uuid [ref: > users.id]
  post_id uuid [ref: > posts.id]
}

Table posts_metrics {
  id int [pk, increment]
  post_id uuid [ref: > posts.id, not null]
  views int [default: 0]
  likes int [default: 0]
  comments int [default: 0]
  reposts int [default: 0]
  Indexes{
    (post_id)
  }
}

Table follow {
  follower_user_id uuid [pk, ref: > users.id, not null]
  following_user_id uuid [pk, ref: > users.id, not null]
  created_at timestamptz [default: `now()`]
  Indexes{
    (follower_user_id, following_user_id)
  }
}


Table reported_posts {
  id int [pk, increment]
  post_id uuid [ref: > posts.id]
  user_id uuid [ref: > users.id]
  reason varchar
  created_at timestamptz [default: `now()`]
  Indexes{
    (post_id, user_id)
  }
}

Table blocked_users {
  id int [pk, increment]
  blocking_user_id uuid [ref: > users.id]
  blocked_user_id uuid [ref: > users.id]
  reason varchar
  created_at timestamptz [default: `now()`]
  Indexes{
    (blocked_user_id, blocking_user_id)
  }
}

Table bookmarks {
  id int [pk, increment]
  user_id uuid [ref: > users.id]
  post_id uuid [ref: > posts.id] 
  created_at timestamptz [default: `now()`]
  Indexes{
    (user_id, post_id)
  }
}

Table moderation_queue {
  id int [pk, increment]
  user_id uuid [ref: > users.id]
  post_id uuid [ref: > posts.id] 
  report_reason varchar
  status varchar // pending, reviewd, etc
  created_at timestamptz [default: `now()`]
  Indexes{
    (user_id, post_id)
  }
}

Table post_mentions {
  id int [pk, increment]
  post_id uuid [ref: > posts.id]
  mentioned_user_id uuid [ref: > users.id]
  Indexes{
    (post_id, mentioned_user_id)
  }
}

/// For Messaging
Table messages {
  id int [pk, increment]
  sender_id uuid [ref: > users.id]
  receiver_id uuid [ref: > users.id]
  content varchar
  created_at timestamptz [default: `now()`]
  updated_at timestamptz
  read boolean
  Indexes{
    (sender_id, receiver_id, id)
  }
}

Table conversation {
  id int [pk, increment]
  user_id_1 uuid [ref: > users.id]
  user_id_2 uuid [ref: > users.id]
  last_msg_id uuid [ref: > messages.id]
  created_at timestamptz [default: `now()`]
  Indexes{
    (user_id_2, id,user_id_1)
  }
}
